
title: ES6 阅读心得之七：Class 类
date: 2019-05-17
tags: [JavaScript,ES6]
---

## Class 类

### 创建
在传统 JavaScript 语言中，并没有类的概念，实现继承是通过构造函数和原型对象来实现的。
在 ES6 中提供了 Class 类的概念，但是它只是一个语法糖，背后实现机制并没有变。

ES6 通过 class 关键字定义一个“类”，其内部包含一个 constructor 方法，即构造方法，而 this 关键字则代表实例对象。
然后在类里可以直接放入函数来定义类的方法，不需要加上 function 这个关键字，方法之间也不需要逗号。

```javascript
class Person {
    constructor(name) {
        this.name = name;
    }
    sayHello() {
        return 'Hello, ' + this.name + '!';
    }
    print() {
        console.log(this.sayHello());
    }
}
```

在类上面依然有构造函数的 prototype 属性，事实上，类的所有方法都定义在其 prototype 属性上面。所以类的新方法通过 Object.assign 一次添加多个方法。

```javascript
Object.assign(Person.prototype, {
    toString() {},
    toValue() {}
});
```
> 注：类的内部所有定义的方法，都是不可枚举的（non-enumerable）;但是通过 prototype 属性后期添加的是可枚举的。
```javascript
console.log(Object.keys(Person.prototype)); // [ "toString", "toValue" ] 没有 "sayHello"、"print"
```

### 构造方法

constructor 方法是类的默认方法，通过 new 命令生成对象实例时，自动调用该方法。一个类必须有 constructor 方法，如果没有显式定义，一个空的 constructor 方法会被默认添加。
constructor 方法默认返回实例对象（即this），可以指定返回其他值。
类必须使用 new 调用，否则会报错。这是它跟普通构造函数的一个主要区别。

```javascript
class Person {}
// 等同于
class Person {
    constructor() {
    }
}
Person() // 报错
```

实例的属性除非显式定义在其本身（即定义在 this 对象上），否则都是定义在原型上（即定义在 class 上）。

```javascript
let person = new Person('Tom');
person.hasOwnProperty('name') // true
person.hasOwnProperty('sayHello') // false
```

### 取值和存值

在类的内部可以使用 get 和 set 关键字，对某个属性设置存值函数 getter 和取值函数 setter，拦截该属性的存取行为。
```javascript
class Person {
    constructor(name) {
        this.name = name;
    }

    get realName() {
        return 'No one';
    }
    set realName(value) {
        this.name = value;
    }
}
let person = new Person('Tom');
console.log('name == ', person.name);
console.log('realName == ', person.realName);
person.realName = 'No one';
console.log('name == ', person.name);
```

> 注：对于仅仅设置了 get 方法的属性（getter-only），不能在 this 对象显示定义同名属性

### 几个关键点

- 严格模式
    类和模块的内部，默认就是严格模式，所以不需要使用 use strict 指定。
- 不存在变量提升
    类不存在变量提升（hoist），所以在使用类时，必须首先定义；包括子类继承父类时，也要保证父类在前。
- name 属性
    ES6 类只是 ES5 构造函数的语法糖，所以函数的许多特性都被 Class 继承，包括name属性。
    ```javascript
    class Person {}
    Person.name // "Person"
    ```
- this 指向
    类的方法内部如果含有 this，它默认指向类的实例。但是，单独使用该方法时，需要注意。

    ```javascript
    class Person {
        constructor(name) {
            this.name = name;
        }
        sayHello() {
            return 'Hello, ' + this.name + '!';
        }
        print() {
            console.log(this.sayHello());
        }
    }
    let person = new Person('Tom');
    let {print} = person;
    print(); // TypeError: this is undefined
    ```

    因为这个方法提取出来单独使用，this 会指向该方法运行时所在的环境（由于严格模式，所以 this 实际指向的是 undefined），从而导致报错。

    解决方法是，在构造方法中绑定 this，或者使用箭头函数。
    ```javascript
    this.print = this.print.bind(this);
    // 或
    this.print = () => {
        console.log(this.sayHello());
    };
    ```

### super 关键字

```javascript
class Parent {
    constructor() {
        // 实例的属性和方法
        this.instanceProp = 111;
        this.instanceMethod = function() {
            console.log('Parent instanceMethod == ', this);
        };
    }
    // 原型方法，可以被实例继承
    protoMethod() {
        console.log('Parent protoMethod == ', this.instanceProp, this.protoProp, this.staticProp);
    }
    // 静态方法，只能被构造函数调用
    static staticMethod() {
        console.log('Parent staticMethod == ', this.instanceProp, this.protoProp, this.staticProp);
    }
}
// 原型属性，只能通过这种方法定义
Parent.prototype.protoProp = 222;
// 静态属性，只能通过这种方法定义
Parent.staticProp = 333;

let a = new Parent();
a.protoMethod();
Parent.staticMethod();

class Child extends Parent {
    constructor() {
        super();
        // super 作为对象使用，赋值时是 this，取值时是 父类原型 而非 父类实例
        super.instanceProp = 444;
        console.log('Parent instanceProp == ', super.instanceProp);
        console.log('Parent protoProp == ', super.protoProp);
    }
    protoMethod() {
        // super 指向 父类原型
        return super.protoMethod();
    }
    static staticMethod() {
        // super 指向 父类 而非 父类原型
        return super.staticMethod();
    }
}
Child.staticProp = 555;

let b = new Child();
b.protoMethod();
Child.staticMethod();
```
