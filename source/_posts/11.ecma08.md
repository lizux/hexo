title: JavaScript读书心得之八：CSS修改（CSS DOM）
date: 2015-09-24
tags: [JavaScript]
---
修改CSS有四种方法：
1. 修改元素的style属性
2. 改变元素的class或id
3. 向文档中写入新的CSS
4. 改变整个文档的样式表
一般规则：③在特殊的可访问性场合使用，④很少用到；推荐使用②，因为这个符合表现和行为分离的原则，而①在某些情况下有用：隐藏或显示元素、动画

## CSS读写

### 内联样式
* 当需要读取内联样式和修改样式时使用style属性
* style对象对每个内联的CSS声明都有一个对应的属性，但是它不能读取外部样式表的CSS属性，所以style属性更适合设置样式，而不是读取它们
* style属性和CSS属性对应的规则是把CSS属性名移除破折号“-”，然后相邻首字母大写，也就是Camel驼峰命名法。如`font-size=>style.fontSize`、`border-left-width=>style.borderLeftWidth`
>   注：对于float属性，在IE8-中使用styleFloat，在其他浏览器中使用cssFloat
    注：设置复合属性时使用cssText属性，如`elem.style.cssText = "font-weight:bold ; color:red;";`
    注：修改style的属性为数值（除0以外）时，必须加上单位，如“px”、“em”

### 非内联样式
当需要读取非内联样式时：
1. IE使用`currentStyle`属性，它可以读取应用在元素上的实际样式，另外它是只读的
2. IE9+、现代浏览器使用`window.getComputedStyle()`方法
>   注：在读取尺寸值时，总是返回px值，尽管原来的样式可能是1em
    注：另外返回color值时使用rgb(255,255,255)这样的语法
    注：当样式采用简写方式（如`border:1px solid #F00`）时，不同浏览器的返回数值会有差异
        如：Firefox无法读取border-width的值，只能读取border-left-width的值

``` javascript
// 读取元素CSS样式 by John Resig
function getStyle(elem, name){
    if (elem.style[name]) {
        return elem.style[name];
    } else if (elem.currentStyle) {
        return elem.currentStyle[name];
    } else if (document.defaultView && document.defaultView.getComputedStyle) {
        name = name.replace(/([A-Z])/g, '-$1');
        name = name.toLowerCase();
        var s = document.defaultView.getComputedStyle(elem, '');
        return s && s.getPropertyValue(name);
    } else {
        return null;
    }
}
function testStyle(){
    var elem = document.getElementById("testdiv");
    var scolor = getStyle(elem, "color");
    var sbwidth = getStyle(elem, "borderLeftWidth");
    var sfont = getStyle(elem, "fontSize");
    var smargin = getStyle(elem, "marginTop");
    var swidth = getStyle(elem, "width");
    console.log(scolor+"："+sbwidth+"："+sfont+"："+smargin+"："+swidth);
}
```

### CSS模块的侦测
CSS的规格发展太快，新的模块层出不穷。不同浏览器的不同版本，对CSS模块的支持情况都不一样。有时候，需要知道当前浏览器是否支持某个模块，这就叫做“CSS模块的侦测”。
一个比较普遍适用的方法是，判断某个DOM元素的style对象的某个属性值是否为字符串。
``` javascript
typeof element.style.transform === 'string';
```

## 改变class和id
通过改变元素的class或id，浏览器会自动更新元素的样式，JavaScript使用className来读取class属性
> 注：由于id具有唯一性，而且还可能作为脚本的钩子，所以不建议改变它
注：因为元素通常已经拥有classs属性了，所以一般是给元素添加或移除一个class值，而不是直接重新设置class值

辅助移除class函数
``` javascript
function removeClass(elem, sClass) {
    elem.className = elem.className.replace(sClass, "");
}
function testClass(){
    var elem = document.getElementById("testdiv").getElementsByTagName("p");
    for (var i = 0,obj; obj=elem[i++];) {
        obj.onclick = function(){
            if (superClass(this, "has", "error")) {
                superClass(this,"remove","error");
            } else {
                superClass(this,"add","error");
            }
        };
    }
}
```

## 向文档写入CSS

* 这个方法比较特别，应该只用来增强页面的可访问性：当JavaScript可用时，定义样式（通常是隐藏页面元素）；如果JavaScript不可用或对象检测失败，不应用该样式
    注：这种解决方案可能会影响某些可用性，但是从技术上说，对于高级的、可执行脚本的界面来说，这是最正确的隐藏元素的处理方法
``` javascript
    document.write("<style>.show{color:#F00}</style>");
    document.write("<link rel='stylesheet' href='style.css'>");
```

* 使用这个方法时，尽快应用特定的样式很重要。因为如果等待load事件的话，用户会看到页面闪烁或跳动（由于某些可见的元素在onload后隐藏或者显示）；另外在页面加载完后，执行`document.write()`，浏览器会默认移除当前文档内容，并写入新的内容，从而破坏掉页面。所以要把`document.write()`放在JavaScript文件的顶端，并在任何函数之外

* 正确地使用这个方法，它就是很有用的可访问性工具，否则会引发一系列问题。在使用`document.write()`添加样式之前，需要整体考虑，并在禁用JavaScript的情况下测试页面

## 改变整个样式表

只有Windows平台下的IE和Firefox支持改变样式表，所以这个方法也遇到了兼容性问题；另外除了某些特定情况（比如目前博客网站流行的允许用户自定义样式表），改变页面的整个样式表也没有什么意义

原理：文档包含一系列样式表文件，样式表包含一系列规则，规则包含一系列样式声明，声明包含属性和对应值

``` javascript
function changeStyle(){
    // 支持样式表编辑的首要条件是支持document.styleSheets节点列表，列表的索引数字按样式表文件在文档中出现的顺序排列
    var sheets = document.styleSheets;
    if (!sheets || !sheets.length) {
        return false;
    }

    // 查找链接地址是style.css的对应样式表对象
    for (var i = 0; i < sheets.length; i++) {
        if (!sheets[i].href) {
            continue;
        }
        var ssName = sheets[i].href.substring(sheets[i].href.lastIndexOf('/')+1);
        if (ssName == 'style.css') {
            var currentSheet = sheets[i];
        }
    }
    // 或者直接设置文档的第一个样式表为样式表对象
    var currentSheet = sheets[0];

    // 读取样式表的所有规则，Firefox使用W3C标准的cssRules[]，IE使用微软标准的rules[]，其他现代浏览器都支持；它们除了名字不同外几乎没有差别
    var sheetRules = currentSheet.cssRules || currentSheet.rules;
    if (!sheetRules) {
        return false;
    }

    // 每个规则都有selectorText属性，以字符串类型保存着规则的选择符，注：IE/Safari返回大写字符，现代浏览器返回小写字符
    var sText = sheetRules[2].selectorText;
    // 每个规则都有style属性，这个和元素的style属性类似
    var sStyle = sheetRules[2].style.font;
    console.log(sText+"的font样式是"+sStyle);

    // 读取样式表的完整文本要用cssText属性，但是全文的（cssText1）只有IE支持，单个规则的（cssText2）则只有IE9+、现代浏览器支持，单个规则并不包含选择符的（cssText3）所有浏览器都支持
    // 对于简写方式的样式，Firefox返回实际值，IE/Opera返回拆分成单个条目后的值
    var cssText1 = currentSheet.cssText;
    if (currentSheet.cssRules) {
        var cssText2 = currentSheet.cssRules[0].cssText;
        var cssText3 = currentSheet.cssRules[0].style.cssText;
    } else if (currentSheet.rules) {
        var cssText2 = currentSheet.rules[0].cssText;
        var cssText3 = currentSheet.rules[0].style.cssText;
    }
    console.log("IE支持的 "+cssText1);
    console.log("现代浏览器支持的 "+cssText2);
    console.log("都支持的 "+cssText3);

    // 添加和移除规则，Firefox使用W3C标准的insertRule()和deleteRule()方法，IE使用微软标准的addRule()和removeRule()方法
    // 通用添加和移除样式表规则函数
    function addCSS(obj, selector, declaration, index) {
        if (obj.insertRule) {
            obj.insertRule(selector+"{"+declaration+"}",index);
        } else if (obj.addRule) {
            obj.addRule(selector,declaration,index);
        }
    }
    function removeCSS(obj, index) {
        if (obj.deleteRule) {
            obj.deleteRule(index);
        } else if (obj.removeRule) {
            obj.removeRule(index);
        }
    }
    addCSS(currentSheet,"a","color:#F00;font-weight:bold;",10);
}
```

## 隐藏或显示元素

* 使用style属性设置内联样式，这样可以通过`style.display`来读取当前元素的display值
* 使用JavaScript设置关键的`display:none`，而不是在CSS里面，这样当用户禁用脚本时，所有内容还是显示的，并可以访问
* 页面加载完后建立标题和关联内容之间的关系

下面的函数遍历文档的h3，并把其后面的内容放入一个新创建的div隐藏起来，然后添加切换显示的脚本
``` javascript
function initToggle(){
    var header = document.getElementsByTagName("h3");
    for (var i = 0; i < header.length; i++) {
        var nDiv = document.createElement("div");
        nDiv.className = "toggle";
        //nDiv.style.display = "none";
        insertAfter(nDiv,header[i]);
        while (nDiv.nextSibling != header[i+1]) {
            nDiv.appendChild(nDiv.nextSibling);
        }
        superClass(header[i],"add","clickable");
        header[i].relatedCont = nDiv;
        header[i].onclick = toggleCont;
    }
}
function toggleCont(){
    var currentValue = this.relatedCont.style.display;
    var newValue = (currentValue == "none") ? "" : "none";
    this.relatedCont.style.display = newValue;
}
```

## 动画

动画就是反复改变元素的某一样式，这也是一个改变style属性优于改变class属性的场合

动画通常涉及到两个函数setTimeout()、setInterval()，而二者选用其一的原则是：前者适合有确定起点和终点的动画，后者适合在不确定的时间内（如等待用户行为）持续进行的动画

> 注：现在更推荐使用CSS3中的transition、animation属性来实现

``` javascript
function initMotion(){
    var obj = document.getElementById("linkList");
    if (!obj) {
        return false;
    }
    var show = document.createElement("div");
    show.id = "slideShow";
    show.innerHTML = "<img src='images/topics.gif' id='linkPic'>";
    insertAfter(show,obj);
    var link = obj.getElementsByTagName("a");
    for (var i = 0; i < link.length; i++) {
        link[i].newId = i;
        link[i].onmouseover = function(){
            motion("linkPic",-100*(this.newId+1),0,10);
        };
    }
}
// 通用移动元素位置函数 by Jeremy Keith
function motion(objId, posX, posY, interval) {
    var k = 0.1;
    var obj = document.getElementById(objId);
    if (!obj) {
        return false;
    }
    if (obj.movement) {
        clearTimeout(obj.movement);
    }
    obj.style.left = obj.style.left || "0px";
    obj.style.top = obj.style.top || "0px";

    var nowX = parseInt(obj.style.left);
    var nowY = parseInt(obj.style.top);
    if (nowX == posX && nowY == posY) {
        return true;
    }
    if (nowX < posX) {
        nowX += Math.ceil((posX-nowX)*k);
    }
    if (nowX > posX) {
        nowX -= Math.ceil((nowX-posX)*k);
    }
    if (nowY < posY) {
        nowY += Math.ceil((posY-nowY)*k);
    }
    if (nowY > posY) {
        nowY -= Math.ceil((nowY-posY)*k);
    }
    obj.style.left = nowX+"px";
    obj.style.top = nowY+"px";
    // 闭包的应用
    obj.movement = setTimeout(function(){
        motion(objId, posX, posY, interval);
    }, interval);
}
```

## 元素的尺寸和位置

### clientWidth、clientHeight属性
元素的可视尺寸（相当于CSS中的content+padding再减去scrollbar），不包括边框border和滚动条scrollbar。
> IE6中该尺寸包括滚动条scrollbar。
  若CSS中设置box-sizing:content-box时，设置的width/height就等于content的尺寸。
  若CSS中没有指定元素的高度和宽度(即自适应)，则IE6中显示0，而其他浏览器则显示实际值。

为了读取文档视口的尺寸，需要查询clientWidth/Height时的兼容性方案：
``` javascript
var windowWidth = document.documentElement.clientWidth || document.body.clientWidth;
var windowHeight = document.documentElement.clientHeight || document.body.clientHeight;
```
> `document.documentElement.clientWidth/clientHeight`，基本上与`window.innerWidth/innerHeight`同义。只有一个区别，前者不将滚动条计算在内，而后者包括了滚动条的高度和宽度。

### offsetWidth、offsetHeight属性
元素的布局尺寸，包括边框和滚动条。我们在浏览器中看到的元素物理尺寸就是这个。
> 若CSS中设置box-sizing:border-box时，设置的width/height就等于offsetWidth/offsetHeight。

### scrollWidth、scrollHeight属性
元素的实际尺寸；如果该属性大于clientWidth/Height，就会出现滚动条。

### 三者之间的关系
#### 定义
    窗口宽度 window.innerWidth
    窗口高度 window.innerHeight
    // 注：由于IE11的滚动条自动隐藏（尺寸为0），所以它的窗口尺寸和视口尺寸是相等的

    视口宽度 clientWidth  = 窗口宽度 - 滚动条
    视口高度 clientHeight = 窗口高度 - 滚动条
    // 定义明确，与窗口尺寸关联

    布局宽度 offsetWidth
    布局高度 offsetHeight
    // 不同浏览器、不同标签下差异较大，见下文公式辨析

    实际宽度 scrollWidth  = 内容宽度
    实际高度 scrollHeight = 内容高度
    // 定义明确，与内容尺寸关联（除了两个例外情况）

#### 公式
    对<html>标签（document.documentElement）来说：
    // 宽度
        // 布局宽度 = 视口宽度 IE8+、Chrome、Firefox
        // 布局宽度 = 窗口宽度 IE6
    // 高度
        // 布局高度 = 内容高度 Chrome、Firefox
        // 布局高度 = 视口高度 IE8+
        // 布局高度 = 窗口高度 IE6
        // 实际高度 = Math.max(内容高度, 视口高度) Firefox 唯一例外

    对<body>标签（document.body）来说：
    // 宽度
        // 布局宽度 = 视口宽度 IE8+、Chrome、Firefox
        // 视口宽度 = 布局宽度 = 实际宽度 = 内容宽度 IE6
    // 高度
        // 视口高度 = 布局高度 = 实际高度 = 内容高度
        // 实际高度 = Math.max(内容高度, 窗口高度 - 滚动条) Chrome 唯一例外

> 注：由于<html>和<body>有了margin、padding、border的话，Firefox和IE会产生很多不兼容问题，所以<html>、<body>一般都重置为0

### offsetLeft、offsetTop属性
元素相对参考点的偏移量

### offsetParent属性
指向参考点，即当前HTML元素的最靠近的、并且CSS的position属性不等于static的祖先元素。IE6则是查找拥有“layout”的祖先元素。
* 最终offsetParent（即最终参考点），一般指向<body>标签；另外由于<html>和<body>标签没有offsetParent，所以它们也没有offsetLeft/Top
* position:relative和absolute的元素，IE6按正常原则查找offsetParent，但其最终的offsetParent会跳过<body>标签，直接指向<html>标签
* position:fixed的元素，IE6浏览器按正常原则查找，其他浏览器的offsetParent为null。
* display:none的元素，IE6浏览器按正常原则查找，IE8浏览器的offsetParent为<body>标签，其他浏览器为null。

### scrollLeft、scrollTop属性
页面的滚动偏移量
> 只有在有滚动条的元素或页面中才有值
  对IE6+、Firefox、Opera来说，`document.documentElement`有此属性；对Safari、Chrome来说，则`document.body`有此属性


 ``` javascript
   // 读取元素坐标（相对于页面） by John Resig
    function pageX(elem){
        return elem.offsetParent ? (elem.offsetLeft + pageX(elem.offsetParent)) : elem.offsetLeft;
    }
    function pageY(elem){
        return elem.offsetParent ? (elem.offsetTop + pageY(elem.offsetParent)) : elem.offsetTop;
    }
    // 注：现代浏览器有个原生方法 getBoundingClientRect()，可以直接获取元素相对于视口的left、top、right、bottom、width、height（最后两项IE8-不支持）

    // 读取元素坐标（相对于父元素） by John Resig
    function parentX(elem){
        return elem.parentNode == elem.offsetParent ? elem.offsetLeft : pageX(elem) - pageX(elem.parentNode);
    }
    function parentY(elem){
        return elem.parentNode == elem.offsetParent ? elem.offsetTop : pageY(elem) - pageY(elem.parentNode);
    }
```

// 下面这个函数显示了IE和Firefox在读取页面元素的各种尺寸上的差异
``` javascript
// 读取页面及视口尺寸
function getPageSize(){
    var xScroll, yScroll;
    if (document.body.scrollHeight > document.body.offsetHeight) {
        xScroll = document.body.scrollWidth;
        yScroll = document.body.scrollHeight;
    } else {
        xScroll = document.body.offsetWidth;
        yScroll = document.body.offsetHeight;
    }
    var windowWidth, windowHeight;
    if (self.innerHeight) {
        windowWidth = self.innerWidth;
        windowHeight = self.innerHeight;
    } else if (document.documentElement && document.documentElement.clientHeight) {
        windowWidth = document.documentElement.clientWidth;
        windowHeight = document.documentElement.clientHeight;
    } else if (document.body) {
        windowWidth = document.body.clientWidth;
        windowHeight = document.body.clientHeight;
    }
    pageWidth = xScroll < windowWidth ? windowWidth : xScroll;
    pageHeight = yScroll < windowHeight ? windowHeight : yScroll;
    return [pageWidth, pageHeight, windowWidth, windowHeight];
}
function elemDimension(){
    var w = window.screen.width;
    var h = window.screen.height;
    var aw = window.screen.availWidth;
    var ah = window.screen.availHeight;
    var iw = window.innerWidth;
    var ih = window.innerHeight;

    var elem = document.documentElement;
    var elem = document.body;
    var elem = document.getElementById("display");
    if (!elem) {
        return false;
    }
    var cw = elem.clientWidth;
    var ch = elem.clientHeight;
    var ow = elem.offsetWidth;
    var oh = elem.offsetHeight;
    var sw = elem.scrollWidth;
    var sh = elem.scrollHeight;
    var ol = elem.offsetLeft;
    var ot = elem.offsetTop;
    var op = elem.offsetParent;
    console.log("窗口宽度："+iw+"\n窗口高度："+ih+"\n视口宽度："+cw+"\n视口高度："+ch+"\n布局宽度："+ow+"\n布局高度："+oh+"\n实际宽度："+sw+"\n实际高度："+sh+"\n相对左偏移："+ol+"\n相对顶偏移："+ot+"\n参考点："+op.nodeName);
    var str = "";
    str += "屏幕宽度Window.screen.width = "+w;
    str += "<br>屏幕高度Window.screen.height = "+h;
    str += "<br>屏幕有效宽度Window.screen.availWidth = "+aw;
    str += "<br>屏幕有效高度Window.screen.availHeight = "+ah;
    if (window.innerWidth) {
        str += "<br>窗口宽度Window.innerWidth = "+iw;
        str += "<br>窗口高度Window.innerHeight = "+ih;
    }
    str += "\n<br>页面宽度 = "+getPageSize()[0];
    str += "\n<br>页面高度 = "+getPageSize()[1];
    str += "\n<br>视口宽度 = "+getPageSize()[2];
    str += "\n<br>视口高度 = "+getPageSize()[3];

    if (document.documentElement) {
        str += "<br><br>视口宽度document.documentElement.clientWidth = "+document.documentElement.clientWidth;
        str += "<br>视口高度document.documentElement.clientHeight = "+document.documentElement.clientHeight;
        str += "<br>布局宽度document.documentElement.offsetWidth = "+document.documentElement.offsetWidth;
        str += "<br>布局高度document.documentElement.offsetHeight = "+document.documentElement.offsetHeight;
        str += "<br>实际宽度document.documentElement.scrollWidth = "+document.documentElement.scrollWidth;
        str += "<br>实际高度document.documentElement.scrollHeight = "+document.documentElement.scrollHeight;
        str += "<br>水平滚动document.documentElement.scrollLeft = "+document.documentElement.scrollLeft;
        str += "<br>垂直滚动document.documentElement.scrollTop = "+document.documentElement.scrollTop;
    }
    if (document.body) {
        str += "<br><br>视口宽度document.body.clientWidth = "+document.body.clientWidth;
        str += "<br>视口高度document.body.clientHeight = "+document.body.clientHeight;
        str += "<br>布局宽度document.body.offsetWidth = "+document.body.offsetWidth;
        str += "<br>布局高度document.body.offsetHeight = "+document.body.offsetHeight;
        str += "<br>实际宽度document.body.scrollWidth = "+document.body.scrollWidth;
        str += "<br>实际高度document.body.scrollHeight = "+document.body.scrollHeight;
        str += "<br><br>CSS宽度document.body.style.width = "+getStyle(document.body, "width");
        str += "<br>CSS高度document.body.style.height = "+getStyle(document.body, "height");
        str += "<br>水平滚动document.body.scrollLeft = "+document.body.scrollLeft;
        str += "<br>垂直滚动document.body.scrollTop = "+document.body.scrollTop;
    }
    document.getElementById("display").innerHTML = str;
}
```